module Example.Hooks.UseEvent
  ( useEvent
  , subscribeTo
  , subscribeTo'
  , UseEvent
  , EventEqFn
  , EventProps
  , EventApi
  )
  where

import Prelude

import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype)
import Data.Traversable (for_)
import Data.Tuple.Nested ((/\))
import Halogen.Hooks (HookM, Hooked, MemoValues, UseEffect, UseState, Hook, useState)
import Halogen.Hooks as Hooks

newtype UseEvent a hooks = UseEvent (UseState (Maybe a) hooks)

derive instance newtypeUseEvent :: Newtype (UseEvent a hooks) _

type EventEqFn a =
  { state :: Maybe a } -> { state :: Maybe a } -> Boolean

type EventProps slots output m a hooked =
  { capturesWith :: EventEqFn a -> (MemoValues -> hooked) -> hooked
  , subscribe :: (a -> HookM slots output m Unit) -> HookM slots output m Unit
  }

type EventApi slots output m a hooked =
  { push :: a -> HookM slots output m Unit
  , props :: EventProps slots output m a hooked
  }


-- | Allows you to "push" events that occur inside a hook
-- | to outside of the hook, so that some end-user
-- | can 1) handle those events when they occur while 2) having
-- | full access to the API exposed to the hook in its returned value:
-- | ```
-- | -- in your custom Hook code...
-- | onSomeEvent <- useEvent
-- |
-- | -- somewhere in your HookM code
-- |   onSomeEvent.push "user clicked foo"
-- |
-- | Hooks.pure
-- |   { onSomeEvent: onSomeEvent.props }
-- |
-- | --------------
-- | -- in end-user code
-- |
-- | someLib <- useSomeLibHook
-- | subscribeTo someLib.onSomeEvent \string -> do
-- |   Hooks.raise ("Event occurred: " <> string)
-- | ```
useEvent
  :: forall output hookMToHooked m slots a
   . Hook slots output m (UseEvent a) (EventApi slots output m a hookMToHooked)
useEvent = Hooks.wrap Hooks.do
  state /\ tState <- useState Nothing

  Hooks.pure { push: \value -> Hooks.put tState (Just value)
             , props: { capturesWith: \eqFn -> Hooks.capturesWith eqFn { state }
                      , subscribe: \cb -> do
                          state' <- Hooks.get tState
                          for_ state' cb
                          Hooks.put tState Nothing
                      }
             }

-- | No, I do not know what the heck this type signature means.
-- | It was generated by the compiler and all attempts to clean it up
-- | and make it legible failed. This is the same as
-- | `subscribeTo' props (==) callback`.
-- |
-- | Long story short, it cleans up what you would otherwise write.
-- | This...
-- | ```
-- | someLib <- useSomLibHook
-- | subscribeTo someLib.onSomeEvent \string -> do
-- |   Hooks.put stateToken ("Event occurred: " <> string)
-- | ```
-- | ... instead of this ...
-- | ```
-- | someLib <- useSomLibHook
-- | someLib.onSomeEvent.capturesWith (==) Hooks.useTickEffect do
-- |   someLib.onSomeEvent.subscribe \string -> do
-- |      Hooks.put stateToken ("Event occurred: " <> string)
-- |   pure Nothing
-- | ```

subscribeTo
  :: forall t63 t64 t65 t66 t67 t68 t69 t70 t71 t73
   . Discard t67
  => Bind t66
  => Applicative t66
  => Eq t73
  => { capturesWith
        :: (t73 -> t73 -> Boolean)
        -> ( MemoValues
          -> HookM t68 t69 t70 (Maybe (HookM t68 t69 t70 Unit))
          -> (forall hooks. Hooked t68 t69 t70 hooks (UseEffect hooks) Unit)
           )
        -> t66 (Maybe t64)
        -> t63
     , subscribe :: t71 -> t66 t67
     | t65
     }
     -> t71 -> t63
subscribeTo props cb =
  subscribeTo' props (==) cb

-- | No, I do not know what the heck this type signature means.
-- | It was generated by the compiler and all attempts to clean it up
-- | and make it legible failed.
-- |
-- | Long story short, it cleans up what you would otherwise write.
-- | This...
-- | ```
-- | someLib <- useSomLibHook
-- | subscribeTo someLib.onSomeEvent (==) \string -> do
-- |   Hooks.put stateToken ("Event occurred: " <> string)
-- | ```
-- | ... instead of this ...
-- | ```
-- | someLib <- useSomLibHook
-- | someLib.onSomeEvent.capturesWith (==) Hooks.useTickEffect do
-- |   someLib.onSomeEvent.subscribe \string -> do
-- |      Hooks.put stateToken ("Event occurred: " <> string)
-- |   pure Nothing
-- | ```
subscribeTo'
  :: forall t48 t49 t53 t54 t55 t57 t59 t62 t66 t67
   . Discard t57
  => Bind t59
  => Applicative t59
  => { capturesWith
        :: t48
        -> ( MemoValues
          -> HookM t55 t54 t53 (Maybe (HookM t55 t54 t53 Unit))
          -> (forall hooks. Hooked t55 t54 t53 hooks (UseEffect hooks) Unit)
           )
        -> t59 (Maybe t66)
        -> t67
      , subscribe :: t49 -> t59 t57
      | t62
      }
  -> t48
  -> t49
  -> t67
subscribeTo' props eqFn cb =
  props.capturesWith eqFn Hooks.useTickEffect do
    props.subscribe cb
    pure Nothing
